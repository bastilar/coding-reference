1. Order of functions written matter. Compiler reads from top to bottom so if a function(A) needs to call another function(B), function (B) must be above function (A).
Talk about thinking in reverse. Yikes.

2. To skip lines in printing, use either:

std::cout << "Some text displayed here" << std::endl; //(messy and long)
or:
std::cout << "Some text displayed here \n";

3.         std::cin.clear(); //clear alphanumeric errors
        std::cin.ignore(); //clear weird character/symbol errors
Funny enough, we may not need these as unreal apparently takes care of this automatically.

4. can set boolean variables equal to a function that returns a bool to determine when a while loop remains true or false or vice versa:
while(true)
    {
        bool bLevelComplete = PlayGame();
    }
    
5. Variables have scope or limits to a local function or where it is declared. TO get around this, you need to pass these variables into the arguments
of function calls that will take that variable and data type.

6. Unreal engine's own C++ requires that we include TEXT() macros to ensure that our strings are read by different build platforms.
Usage:
FString HiddenWord = TEXT("nuts");

7. Turns out unreal engine has a bug where it won't compile your new code so you need to hit compile again. To be safe in the future, compile twice. I just had this
bug happen.

8. The Fstring::Printf() function is used to display different data types so you can print out things like "The canary has xyz eyes." Format:
PrintLine(FString::Printf(TEXT("The hidden word is: %s and is %i characters long."), *HiddenWord, HiddenWord.Len())); //debugline to turn off or on
%s for string words
%i for integers
%c for single characters in a word
%f for floats
Probably other data types exists, remember to add to me later.

9. return; can be used to exit out of code early, like an if block. This helps prevent wasting resources running through other code. Such use won't be as needed
if you can simplify your code to very little, specific functions like having just 1 to 3 if/else statements.

10. The reason we have an asterisk before a variable name, usually before a FString type variable, is because we need a pointer (address in memory) to store the variable
that will likely have different sizes and thus needs the asterisk * to access it properly, otherwise you probably get some kind of error if you change the variable's
value like "cake" to "cakes" and that is a difference in size. Something like an int32 doesn't need a pointer because its value is always going to be stored in memory
as the same size, namely a 32 bit integer in memory or 4bytes.

11. Trying to access an element in an array outside of what's assigned to memory will crash unreal engine. For example, HiddenWord[5] with a 6 char array work "cakes"
(includes the null ending character) will crash unreal because there are 0-4 elements, not 5. Null space apparently does not count as part of the element that you can
call.

12. const TCHAR HW[] = TEXT("cakes"); //Tchar for some reason requires the TEXT("") macro when using const chars

13. advanced cursor manipulation. useful if you need to add cursors to multiple lines at once like in a vertical tarray list that you want to modify
https://www.udemy.com/course/unrealcourse/learn/lecture/16366592#overview

14. Ranged based for loops are written as:
for (FString Word : WordList)
    {
        if (Word.Len() >= 4 && Word.Len() <= 8 && IsIsogram(Word))
        {
            ValidWords.Emplace(Word);
        }
    }

And it is the same as:

for (int32 Index = 0 ; Index < WordList.Len() ; Index++) // declare the type, usually int32, then condition, then increment/decrement)
etc...

15. & is a reference variable. This is used to refer to the original variable without copying it in your code's memory, thus saving resources. An out parameter is 
a reference variable that DOES NOT contain the const modifier. & reference variables however always have the const, or at the least very often does.

16. structs are short for "structures" that store data types. Syntax:
struct Fthensome name
{
        declarations of some kind
};

Note structs always must begin with "F" in unreal. Not sure if this is forced or just common protocol.

Another syntax to change values during specific parts of your code:
FBullCowCount Count = { 2, 3 };
Count.Bulls = 9;

The "Bulls" will be set to 2, then 9.

The reason you probably want to use structs / structures of data is to store a bunch of data or stats like hitpoints, mana, stamina, intelligence, strength, etc.
Then you use classes that declare functions/methods that will likely manipulate those stats.

17. Pointers are *variabletype , not to be confused with multiply, are memory addresses. They are similiar to references in that you refer to an object instead of
copying then manipulating the data, saving memory and performance. Downside is you lose control of the data ownership. Pointers can point to any object.

18. Pointer syntax:
FType* NameOfPointer or FType * NameOfPointer or FType *NameOfPointer
Unreal uses the first way of declaring pointers usually.
FType pointers need ot match their type.

(*SomeActor).GetName() when it is *NOT* a pointer to access the sub functions
SomeActor->GetName() when it *IS* a pointer to access the sub functions
Both variations are the same but this formatting cna help distinquish between referenced and de-referenced pointers

19. Super::BeginPlay() means every code above it in the hierarchy must be run first before executing code below the Super::BeginPlay()

20. Example pointer syntax and accessing its member functions:
	Super::BeginPlay();

	UE_LOG(LogTemp, Warning, TEXT("This is a warning. I am yellow."));
	
	FString Log = TEXT("Hello.");

	FString* PrtLog = &Log; //turn log into a pointer

	Log.Len();

	(*PrtLog).Len(); //dereference a pointer to access member functions
	PrtLog->Len(); //same as above but a lot cleaner

	UE_LOG(LogTemp, Warning, TEXT("%s"), *Log); // overloads the ue_log function to print
												// the fstring pointer, note you need *Log

	//FString ObjectName = GetOwner()->GetName(); // can replace *GetOwner()->GetName() with *ObjectName. Disavantage is you can't use ObjectName again for somereason
	//FString* PrtObjectName = &ObjectName;

	UE_LOG(LogTemp, Warning, TEXT("Object name is: %s"), *GetOwner()->GetName()); //get name of object this component is attached to, much like unity's command

21. If you want to set or modify a rotation of an object, the syntax for using frotator to set a new rotation or using a math function are as follows:
	FRotator CurrentRotation = GetOwner()->GetActorRotation();
	FRotator SetRotation = { 0.0f, (CurrentRotation.Yaw - 90.0f), 0.0f };
	GetOwner()->SetActorRotation(SetRotation);
	
	//new modifier note you can also write SetRotation as:
	FRotator SetRotation2(0.0f, 0.0f, 0.0f);
	
	The unreal documentation doesn't say at all to use {} squiggly brackets for some reason.

22. If you use GetOwner() make sure to remember that if you call it in beginplay() before the actor or object is actually instantiated, you may get a null return value
because it's calling the owner before the owner actually exists.

23. If you find objects are not rotating as they should, consider that you are using absolute values as opposed to relative values. Example:
	
	CurrentYaw = FMath::Lerp(CurrentYaw, TargetYaw, 0.007f);
	FRotator DoorRotation = GetOwner()->GetActorRotation();

	DoorRotation.Yaw = CurrentYaw;

	GetOwner()->SetActorRotation(DoorRotation);
	
This will set and create a placeholder value for the object owner's rotation so you can set it to whatever your game logic requires. In this case it will open the 
door 90 degrees, regardless of the angle it's starting at. If this were absolute, then certain doors would never open because it's yaw is already set to the value
you chose, resulting in a bug.

24. To expose a parameter or variable to be publicly editable in the unreal engine editor, type the following above the variable:

	UPROPERTY(EditAnywhere)
	float TargetYaw = 90.0f;
	
And TargetYaw should show up in the components section of the editor.

25. Make sure to abuse DeltaTime in your code because anything to do with movement or physics can be affected positively by DeltaTime variable. This makes it so everyone
will move at the same rate. Not having it there will mean slower machines will move slower versus faster computers. DeltaTime negates this annoying problem. Example code:

CurrentYaw = FMath::Lerp(CurrentYaw, TargetYaw, DeltaTime * 0.8f);

Where the door will open at the same rate for anyone, regardless of how fast or slow their computer is.

26. Editanywhere, uproperty, and visibleanywhere tips https://forums.unrealengine.com/t/how-do-i-expose-a-variable-in-the-editor-and-make-in-editable/1665/6 cannot
use visible or edit in the same line as a rule.

27. A great way to protect yourself from null pointer / null reference pointer errors (the most annoying error) is to create a check in the log to detail what objects
or actors have null settings on it, making it very easy to find those pesky null errors. Example code:

BeginPlay()
if(!PressurePlate)
	{
		FString TheObjectName = GetOwner()->GetName();
		UE_LOG(LogTemp, Error, TEXT("Actor %s has pressure plate component set to nothing."), *TheObjectName);
	}
See source course https://www.udemy.com/course/unrealcourse/learn/lecture/17698098

28. To get the player actor pawn or default starting player pawn, you will need ot use GetWorld() and PlayerController() methods. Make sure to include the header .h
files:

#include "Engine/World.h"
#include "GameFramework/PlayerController.h"

Syntax:
	ActorThatOpens = GetWorld()->GetFirstPlayerController()->GetPawn(); 
	
29. GetWorld()->GetTimeSeconds() is the method used to get the amount of seconds that have passed in the game world. Useful for creating timers, probably. It seems
to reset often when it gets called so if you need to store time elapses in certain situations, you should save the time into a float variable.

	if(PressurePlate && PressurePlate->IsOverlappingActor(ActorThatOpens))
	{
		OpenDoor(DeltaTime);
		DoorLastOpened = GetWorld()->GetTimeSeconds();
	}
	else
	{
		if(GetWorld()->GetTimeSeconds() - DoorLastOpened > DoorCloseDelay) //if the door has been open for x or more seconds, then close the door
		{
			CloseDoor(DeltaTime);
		}
	}

30. .ToString() can be used for a lot of things apparently. Before complicating things, consider just adding .ToString() at the end of a variable to see if it will
auto complete and you can output that value text to whatever it is you're doing. Example:
	
	FVector PlayerViewPointLocation;
	FRotator PlayerViewPointRotation;
	GetWorld()->GetFirstPlayerController()->GetPlayerViewPoint(OUT PlayerViewPointLocation, OUT PlayerViewPointRotation); // get player's viewpoint

	UE_LOG(LogTemp, Warning, TEXT("The Player viewpoint loc is: %s. The player viewpoint rotationis: %s."), *PlayerViewPointLocation.ToString(), *PlayerViewPointRotation.ToString());
	// log the output
	
31. DrawDebugLine() is useful for casting a debug line out of your character or any object actor for testing and viewing purposes. Lots of parameters syntax:

#include "DrawDebugHelpers.h"

FVector LineTraceDirection = PlayerViewPointRotation.Vector() * Reach;
	FVector LineTraceEnd = PlayerViewPointLocation + LineTraceDirection;

	DrawDebugLine(
	GetWorld(),
	PlayerViewPointLocation,
	LineTraceEnd,
	FColor(0, 255, 0),
	false,
	0.f,
	0,
	5.0f
	);
	
Note when converting TO vectors, it has a default size of 1.0f, or 1 millimeter, so you need to multiply it by the actual length of the line you want to cast out.
Another NOTE, drawdebuglines CANNOT interact with the world or objects (usually) but raycasting CAN.

32. Can also try to detect collision by single object type, clearly important in gaming for say, getting close to weapons, items, pickups, and other useable objects
like doors or levers.

	FHitResult Hit;
		FCollisionQueryParams TraceParams(FName(TEXT("")), false, GetOwner());

		GetWorld()->LineTraceSingleByObjectType(
		OUT Hit,
		PlayerViewPointLocation,
		LineTraceEnd,
		FCollisionObjectQueryParams(ECollisionChannel::ECC_PhysicsBody),
		TraceParams
		);

		AActor* ActorHit = Hit.GetActor();

	if(ActorHit)
	{
		UE_LOG(LogTemp, Warning, TEXT("%s is the object detected."), *ActorHit->GetName() );
	}
	
FCollisionQueryParams has many overloads but the one we're using here takes parameters of name (in this case none), are we using complex or simple collision detection
mode in unreal? (no, so we set this to false), and which actor do we ignore (ourselves so our ray cast doesn't hit us and just return nothing all hte time).

33. Syntax for binding keys to code:
	InputComponent = GetOwner()->FindComponentByClass<UInputComponent>();
	if (InputComponent)
	{
		UE_LOG(LogTemp, Warning, TEXT("Input component found on %s"), *GetOwner()->GetName());
		InputComponent->BindAction("Grab", IE_Pressed, this, &UGrabber::Grab);
	}
	else
	{
		UE_LOG(LogTemp, Error, TEXT("No input component found on object %s"), *GetOwner()->GetName() );
	}
	void UGrabber::Grab()
{
	UE_LOG(LogTemp, Warning, TEXT("Test test grab form ugrabber pressed."));
}
	
Make sure InputComponent is declared in your .header .h header files and you also set the "Grab" in code equal EXACTLY to "Grab" in your unreal editor under:
Project Settings -> Engine -> Input

34. A good primer on when to use scope :: operators, & . operators and -> arrow operators. https://www.udemy.com/course/unrealcourse/learn/lecture/17707310#notes
Still confusing.

35. Class, Enum, Namespace ::
UGrabber::Grab
EwordStatus::OK
std::cout

Scope operators (::) are used to access permanent storage in memory functions. This is determined during compile times so it's always stored permanently.

Instance or reference use . accessor operators
MyGrab.Grab()
MyBullCowCount.Bulls
MyGrabRef.Grab()

dot . operators are used to access functions or methods from free stack memory

-> arrow operators are accessing functions from heap memory, usually when accessing pointer functions

36. Refactoring is pretty important for cleaning up your code, organizing it better, and of course, optimizing code and performance. It's probably a good idea to 
occassionally have your team refactor periodically to make sure everything runs nice and smooth (fast), as well as reduce bug confusion due to having to deal with
unwieldly large blocks of code. I bet companies waste a decent amount of time and money on getting confused with large blocks of code.

37. Apparently your custom made header .h files should be at the top otherwise you will get weird glitches. For example the releasecomponent wasn't working because
grabber.h wasn't included first at the top of the includes section. Weird.

38. When using TArray's, make sure to include the * inside the <> if it's a pointer like so:

	//find all overlapping actors
	TArray<AActor*> OverLappingActors;
	PressurePlate->GetOverlappingActors(OverLappingActors);
	
39. If you're using GetOverlappingActors, make sure the actors/objects that you will check for overlapping with has the tickbox "generate overlapping events" is ticked
yes.

40. When creating new components, through code or using unreal's built in components, make sure to always protect yourself from null pointer reference errors. They're
just as bad as the ones from unity 3d except when unreal crashes it can take out your computer system.

41. When creating a new c++ class from a blueprint, there may be a new issue bug in unreal 4.26 where it cannot find the include. You have to go into the .cpp or .h
(most likely .cpp file) and look at the includes and just trim down the include to say #include "filename.h" instead of "directory/filename.h" easy bug fix.

Afterwards, close everything and start up the project again by clicking the .uproject file and clicking "yes" to rebuilding the project file structure.

42. You can declare a forward declartion of a class instead of using an #include to reduce compile times if you want to just use a specific class.
For example:

class UCapsuleComponent;

Instead of the #include that contains UCapsuleComponent. Forward declaration classes should be declared at the top after the #includes and before everything else.

43. If you need to edit variables in the blueprints section of the unreal engine editor, you need to specify the access modifier BlueprintReadWrite and BlueprintReadOnly

UPROPERTY(EditAnywhere, BlueprintReadWrite)
UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components", meta = (AllowPrivateAccess = "true")) // this is for making private variables visible and getting
around the error.

44. FTimerHandle FireRateTimerHandle; //unreal's way of control timers so we can create timed events

45. To run a timer on an object create a timer variable using a fhandle, get the current object, call a function to be run, set a time interval(float), and then loop
it all the time (true) or just check once(default false)

.h implementation FTimerHandle FireRateTimerHandle;

GetWorld()->GetTimerManager().SetTimer(FireRateTimerHandle, this, &APawnTurret::CheckFireCondition, FireRate, true); // can also use GetWorldTimerManager()

46. Cross class communication uses Cast<>() function the syntax is:

	PlayerPawn = Cast<APawnTank>(UGameplayStatics::GetPlayerPawn(this, 0));
	
This allows us to convert a generic player pawn into a specific class that we created, which is APawnTank. We now gain access to both the generic base pawn class
and APawnTank class's functions. The 0 refers to the first player in the object world (player 0). In multiplayer you likely can specify different players besides
yourself or the player.

47. Dist is used to measure distance between 2 actor objects. Syntax:

float APawnTurret::ReturnDistanceToPlayer()
{
	if(!PlayerPawn)
	{
		return 0.0f;
	}

	//float Distance = FVector().Dist(PlayerPawn->GetActorLocation(), GetActorLocation());
	//return Distance;

	return FVector().Dist(PlayerPawn->GetActorLocation(), GetActorLocation());
}

48. The Super:: function is called to override a function call from a base class or other classes so you can add functionality to the called class. You probably
want to do this to change specific classes in particular situations or actors and be seperate from everyone and everything else.

49. override is used to let the game/system know to expect an overrided virtual or modified function call to the same name but with perhaps different parameters.
Syntax:

protected:
void TEST() override;

50. virtual specifier is needed to actually be able to override or change a base function in the parent class.
Syntax:

protected:
virtual void TEST();

51. In order to properly use override and virtual specifiers, it seems override is used in the child classes and the parent/base class uses the word virtual. So for
example:

PawnBase.h (parent)
virtual void TEST();

PawnTurret.h (child INHERITS parent or PawnBase.h)
void TEST() override;

Doing it this way should make the compilier work and be happy.

In other words:
Use virtual in parent classes
Use override in child classes

52. 
