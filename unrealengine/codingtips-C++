1. Order of functions written matter. Compiler reads from top to bottom so if a function(A) needs to call another function(B), function (B) must be above function (A).
Talk about thinking in reverse. Yikes.

2. To skip lines in printing, use either:

std::cout << "Some text displayed here" << std::endl; //(messy and long)
or:
std::cout << "Some text displayed here \n";

3.         std::cin.clear(); //clear alphanumeric errors
        std::cin.ignore(); //clear weird character/symbol errors
Funny enough, we may not need these as unreal apparently takes care of this automatically.

4. can set boolean variables equal to a function that returns a bool to determine when a while loop remains true or false or vice versa:
while(true)
    {
        bool bLevelComplete = PlayGame();
    }
    
5. Variables have scope or limits to a local function or where it is declared. TO get around this, you need to pass these variables into the arguments
of function calls that will take that variable and data type.

6. Unreal engine's own C++ requires that we include TEXT() macros to ensure that our strings are read by different build platforms.
Usage:
FString HiddenWord = TEXT("nuts");

7. Turns out unreal engine has a bug where it won't compile your new code so you need to hit compile again. To be safe in the future, compile twice. I just had this
bug happen.

8. The Fstring::Printf() function is used to display different data types so you can print out things like "The canary has xyz eyes." Format:
PrintLine(FString::Printf(TEXT("The hidden word is: %s and is %i characters long."), *HiddenWord, HiddenWord.Len())); //debugline to turn off or on
%s for string words
%i for integers
%c for single characters in a word
%f for floats
Probably other data types exists, remember to add to me later.

9. return; can be used to exit out of code early, like an if block. This helps prevent wasting resources running through other code. Such use won't be as needed
if you can simplify your code to very little, specific functions like having just 1 to 3 if/else statements.

10. The reason we have an asterisk before a variable name, usually before a FString type variable, is because we need a pointer (address in memory) to store the variable
that will likely have different sizes and thus needs the asterisk * to access it properly, otherwise you probably get some kind of error if you change the variable's
value like "cake" to "cakes" and that is a difference in size. Something like an int32 doesn't need a pointer because its value is always going to be stored in memory
as the same size, namely a 32 bit integer in memory or 4bytes.

11. Trying to access an element in an array outside of what's assigned to memory will crash unreal engine. For example, HiddenWord[5] with a 6 char array work "cakes"
(includes the null ending character) will crash unreal because there are 0-4 elements, not 5. Null space apparently does not count as part of the element that you can
call.

12. const TCHAR HW[] = TEXT("cakes"); //Tchar for some reason requires the TEXT("") macro when using const chars

13. advanced cursor manipulation. useful if you need to add cursors to multiple lines at once like in a vertical tarray list that you want to modify
https://www.udemy.com/course/unrealcourse/learn/lecture/16366592#overview

14. Ranged based for loops are written as:
for (FString Word : WordList)
    {
        if (Word.Len() >= 4 && Word.Len() <= 8 && IsIsogram(Word))
        {
            ValidWords.Emplace(Word);
        }
    }

And it is the same as:

for (int32 Index = 0 ; Index < WordList.Len() ; Index++) // declare the type, usually int32, then condition, then increment/decrement)
etc...

15. & is a reference variable. This is used to refer to the original variable without copying it in your code's memory, thus saving resources. An out parameter is 
a reference variable that DOES NOT contain the const modifier. & reference variables however always have the const, or at the least very often does.

16. structs are short for "structures" that store data types. Syntax:
struct Fthensome name
{
        declarations of some kind
};

Note structs always must begin with "F" in unreal. Not sure if this is forced or just common protocol.

Another syntax to change values during specific parts of your code:
FBullCowCount Count = { 2, 3 };
Count.Bulls = 9;

The "Bulls" will be set to 2, then 9.

The reason you probably want to use structs / structures of data is to store a bunch of data or stats like hitpoints, mana, stamina, intelligence, strength, etc.
Then you use classes that declare functions/methods that will likely manipulate those stats.

17. Pointers are *variabletype , not to be confused with multiply, are memory addresses. They are similiar to references in that you refer to an object instead of
copying then manipulating the data, saving memory and performance. Downside is you lose control of the data ownership. Pointers can point to any object.

18. Pointer syntax:
FType* NameOfPointer or FType * NameOfPointer or FType *NameOfPointer
Unreal uses the first way of declaring pointers usually.
FType pointers need ot match their type.

(*SomeActor).GetName() when it is *NOT* a pointer to access the sub functions
SomeActor->GetName() when it *IS* a pointer to access the sub functions
Both variations are the same but this formatting cna help distinquish between referenced and de-referenced pointers

19. Super::BeginPlay() means every code above it in the hierarchy must be run first before executing code below the Super::BeginPlay()

20. Example pointer syntax and accessing its member functions:
	Super::BeginPlay();

	UE_LOG(LogTemp, Warning, TEXT("This is a warning. I am yellow."));
	
	FString Log = TEXT("Hello.");

	FString* PrtLog = &Log; //turn log into a pointer

	Log.Len();

	(*PrtLog).Len(); //dereference a pointer to access member functions
	PrtLog->Len(); //same as above but a lot cleaner

	UE_LOG(LogTemp, Warning, TEXT("%s"), *Log); // overloads the ue_log function to print
												// the fstring pointer, note you need *Log

	//FString ObjectName = GetOwner()->GetName(); // can replace *GetOwner()->GetName() with *ObjectName. Disavantage is you can't use ObjectName again for somereason
	//FString* PrtObjectName = &ObjectName;

	UE_LOG(LogTemp, Warning, TEXT("Object name is: %s"), *GetOwner()->GetName()); //get name of object this component is attached to, much like unity's command

21. If you want to set or modify a rotation of an object, the syntax for using frotator to set a new rotation or using a math function are as follows:
	FRotator CurrentRotation = GetOwner()->GetActorRotation();
	FRotator SetRotation = { 0.0f, (CurrentRotation.Yaw - 90.0f), 0.0f };
	GetOwner()->SetActorRotation(SetRotation);
	
	//new modifier note you can also write SetRotation as:
	FRotator SetRotation2(0.0f, 0.0f, 0.0f);
	
	The unreal documentation doesn't say at all to use {} squiggly brackets for some reason.

22. If you use GetOwner() make sure to remember that if you call it in beginplay() before the actor or object is actually instantiated, you may get a null return value
because it's calling the owner before the owner actually exists.

23. If you find objects are not rotating as they should, consider that you are using absolute values as opposed to relative values. Example:
	
	CurrentYaw = FMath::Lerp(CurrentYaw, TargetYaw, 0.007f);
	FRotator DoorRotation = GetOwner()->GetActorRotation();

	DoorRotation.Yaw = CurrentYaw;

	GetOwner()->SetActorRotation(DoorRotation);
	
This will set and create a placeholder value for the object owner's rotation so you can set it to whatever your game logic requires. In this case it will open the 
door 90 degrees, regardless of the angle it's starting at. If this were absolute, then certain doors would never open because it's yaw is already set to the value
you chose, resulting in a bug.

24. To expose a parameter or variable to be publicly editable in the unreal engine editor, type the following above the variable:

	UPROPERTY(EditAnywhere)
	float TargetYaw = 90.0f;
	
And TargetYaw should show up in the components section of the editor.

25. Make sure to abuse DeltaTime in your code because anything to do with movement or physics can be affected positively by DeltaTime variable. This makes it so everyone
will move at the same rate. Not having it there will mean slower machines will move slower versus faster computers. DeltaTime negates this annoying problem. Example code:

CurrentYaw = FMath::Lerp(CurrentYaw, TargetYaw, DeltaTime * 0.8f);

Where the door will open at the same rate for anyone, regardless of how fast or slow their computer is.

26. Editanywhere, uproperty, and visibleanywhere tips https://forums.unrealengine.com/t/how-do-i-expose-a-variable-in-the-editor-and-make-in-editable/1665/6 cannot
use visible or edit in the same line as a rule.

27. 
