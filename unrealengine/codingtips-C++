1. Order of functions written matter. Compiler reads from top to bottom so if a function(A) needs to call another function(B), function (B) must be above function (A).
Talk about thinking in reverse. Yikes.

2. To skip lines in printing, use either:

std::cout << "Some text displayed here" << std::endl; //(messy and long)
or:
std::cout << "Some text displayed here \n";

3.         std::cin.clear(); //clear alphanumeric errors
        std::cin.ignore(); //clear weird character/symbol errors
Funny enough, we may not need these as unreal apparently takes care of this automatically.

4. can set boolean variables equal to a function that returns a bool to determine when a while loop remains true or false or vice versa:
while(true)
    {
        bool bLevelComplete = PlayGame();
    }
    
5. Variables have scope or limits to a local function or where it is declared. TO get around this, you need to pass these variables into the arguments
of function calls that will take that variable and data type.

6. Unreal engine's own C++ requires that we include TEXT() macros to ensure that our strings are read by different build platforms.
Usage:
FString HiddenWord = TEXT("nuts");

7. Turns out unreal engine has a bug where it won't compile your new code so you need to hit compile again. To be safe in the future, compile twice. I just had this
bug happen.

8. The Fstring::Printf() function is used to display different data types so you can print out things like "The canary has xyz eyes." Format:
PrintLine(FString::Printf(TEXT("The hidden word is: %s and is %i characters long."), *HiddenWord, HiddenWord.Len())); //debugline to turn off or on
%s for string words
%i for integers
Probably other data types exists, remember to add to me later.

9. return; can be used to exit out of code early, like an if block. This helps prevent wasting resources running through other code. Such use won't be as needed
if you can simplify your code to very little, specific functions like having just 1 to 3 if/else statements.

10. The reason we have an asterisk before a variable name, usually before a FString type variable, is because we need a pointer (address in memory) to store the variable
that will likely have different sizes and thus needs the asterisk * to access it properly, otherwise you probably get some kind of error if you change the variable's
value like "cake" to "cakes" and that is a difference in size. Something like an int32 doesn't need a pointer because its value is always going to be stored in memory
as the same size, namely a 32 bit integer in memory or 4bytes.

11. Trying to access an element in an array outside of what's assigned to memory will crash unreal engine. For example, HiddenWord[5] with a 6 char array work "cakes"
(includes the null ending character) will crash unreal because there are 0-4 elements, not 5. Null space apparently does not count as part of the element that you can
call.

12. const TCHAR HW[] = TEXT("cakes"); //Tchar for some reason requires the TEXT("") macro when using const chars

13. 
